(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('react')) :
  typeof define === 'function' && define.amd ? define(['react'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.ReactDOM = factory(global.React));
})(this, (function (React) { 'use strict';

  function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
      Object.keys(e).forEach(function (k) {
        if (k !== 'default') {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () { return e[k]; }
          });
        }
      });
    }
    n.default = e;
    return Object.freeze(n);
  }

  var React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);

  const FunctionComponent = 0;
  const HostRoot = 3;
  const HostComponent = 5;
  const HostText = 6;

  const NoFlags = 0b0000000;
  const Placement = 0b0000001;
  const Update = 0b0000010;
  const ChildDeletion = 0b0000100;
  const MutationMask = Placement | Update | ChildDeletion;

  class FiberNode {
      tag;
      pendingProps;
      key;
      stateNode;
      type;
      ref;
      return;
      sibling;
      child;
      index;
      memorizedProps;
      memorizedState;
      alternate;
      flags;
      subtreeFlags;
      updateQueue;
      constructor(tag, pendingProps, key) {
          this.tag = tag;
          this.key = key;
          this.stateNode = null;
          // 例：Functioncomponent type 就是函数本身
          this.type = null;
          /*
           * 构成树状结构
           */
          // 指向父fiberNode
          this.return = null;
          // 指向右边的兄弟fiberNode
          this.sibling = null;
          // 指向子fiberNode
          this.child = null;
          this.index = 0;
          this.ref = 0;
          /*
           * 作为工作单元
           */
          this.pendingProps = pendingProps;
          this.memorizedProps = null;
          this.updateQueue = null;
          this.memorizedState = null;
          this.alternate = null;
          // 副作用
          this.flags = NoFlags;
          this.subtreeFlags = NoFlags;
      }
  }
  class FiberRootNode {
      container;
      current;
      finishedWork;
      constructor(container, hostRootFiber) {
          this.container = container;
          this.current = hostRootFiber;
          hostRootFiber.stateNode = this;
          this.finishedWork = null;
      }
  }
  function createWorkInProgress(current, pendingProps) {
      let wip = current.alternate;
      if (wip === null) {
          // mount
          wip = new FiberNode(current.tag, pendingProps, current.key);
          wip.type = current.type;
          wip.stateNode = current.stateNode;
          wip.alternate = current;
          current.alternate = wip;
      }
      else {
          // update
          wip.pendingProps = pendingProps;
          wip.flags = NoFlags;
          wip.type = current.type;
      }
      wip.flags = current.flags;
      wip.child = current.child;
      wip.updateQueue = current.updateQueue;
      wip.memorizedProps = current.memorizedProps;
      wip.memorizedState = current.memorizedState;
      return wip;
  }
  function createFiberFromElement(element) {
      const { type, key, props } = element;
      let fiberTag = FunctionComponent;
      if (typeof type === 'string') {
          fiberTag = HostComponent;
      }
      else if (typeof type !== 'function' && true) {
          console.warn('未定义的type类型', element);
      }
      const fiber = new FiberNode(fiberTag, props, key);
      fiber.type = type;
      return fiber;
  }

  const createUpdate = (action) => {
      return { action };
  };
  const createUpdateQueue = () => {
      return { shared: { pending: null }, dispatch: null };
  };
  const enqueueUpdate = (updateQueue, update) => {
      updateQueue.shared.pending = update;
  };
  const processUpdateQueue = (baseState, pendingUpdate) => {
      const result = {
          memorizedState: baseState,
      };
      if (pendingUpdate !== null) {
          const action = pendingUpdate.action;
          if (action instanceof Function) {
              // baseState 1 update (x) => 4x -> memorizedState 4
              result.memorizedState = action(baseState);
          }
          else {
              // baseState 1 update 2 -> memorizedState 2
              result.memorizedState = action;
          }
      }
      return result;
  };

  const supportSymbol = typeof Symbol === 'function' && Symbol.for;
  const REACT_ELEMENT_TYPE = supportSymbol ? Symbol.for('react.element') : 0xeac7;

  function ChildReconciler(shouldTrackEffect) {
      // shouldTrackEffect：表示是否需要追踪副作用
      function reconcileSingleElement(returnFiber, currentFiber, element) {
          // 根据reactElement创建fiber
          const fiber = createFiberFromElement(element);
          fiber.return = returnFiber;
          return fiber;
      }
      function reconcileSingleTextNode(returnFiber, currentFiber, content) {
          const fiber = new FiberNode(HostText, { content }, null);
          fiber.return = returnFiber;
          return fiber;
      }
      function placeSingleChild(fiber) {
          // 根据当前情况判断是否给fiber加Placement标记
          // 是一个优化方式，首屏渲染时只有hostRootFiber需要加Placement标记
          if (shouldTrackEffect && fiber.alternate === null /*null表示首屏渲染*/) {
              fiber.flags |= Placement;
          }
          return fiber;
      }
      return function reconcileChildrenFibers(returnFiber, currentFiber, newChild) {
          // 判断新的子节点是什么类型
          // 1. 单一节点（除了HostText）
          if (typeof newChild === 'object' && typeof newChild !== null) {
              switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                      return placeSingleChild(reconcileSingleElement(returnFiber, currentFiber, newChild));
              }
          }
          // TODO 2. 多节点情况
          // 3. HostText
          if (typeof newChild === 'number' || typeof newChild === 'string') {
              return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFiber, newChild));
          }
          {
              console.warn('未实现的reconcile类型', newChild);
          }
          return null;
      };
  }
  const reconcileChildrenFibers = ChildReconciler(true);
  const mountChildrenFibers = ChildReconciler(false);

  const internals = React__namespace.__SECRET__INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

  let currentlyRenderingFiber = null;
  let workInProgressHook = null;
  const { currentDispatcher } = internals;
  function renderWithHooks(wip) {
      currentlyRenderingFiber = wip;
      // 重置，函数组件fiber中memorizedState指向hooks链表
      wip.memorizedState = null;
      const current = wip.alternate;
      if (current !== null) ;
      else {
          // mount
          currentDispatcher.current = HooksDispatcherOnMount;
      }
      const Component = wip.type;
      const props = wip.pendingProps;
      const children = Component(props);
      currentlyRenderingFiber = null;
      return children;
  }
  const HooksDispatcherOnMount = {
      useState: mountState,
  };
  function mountState(initialState) {
      // 找到当前useState对应的hook数据
      const hook = mountWorkInProgressHook();
      let memorizedState;
      if (initialState instanceof Function) {
          memorizedState = initialState();
      }
      else {
          memorizedState = initialState;
      }
      const queue = createUpdateQueue();
      hook.updateQueue = queue;
      hook.memorizedState = memorizedState;
      // @ts-ignore
      const dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
      queue.dispatch = dispatch;
      return [memorizedState, dispatch];
  }
  function dispatchSetState(fiber, updateQueue, action) {
      const update = createUpdate(action);
      enqueueUpdate(updateQueue, update);
      scheduleUpdateOnFiber(fiber);
  }
  function mountWorkInProgressHook() {
      const hook = {
          memorizedState: null,
          next: null,
          updateQueue: null,
      };
      if (workInProgressHook === null) {
          // mount时 第一个hook
          if (currentlyRenderingFiber === null) {
              throw new Error('hooks只能在函数组件中使用');
          }
          else {
              workInProgressHook = hook;
              currentlyRenderingFiber.memorizedState = workInProgressHook;
          }
      }
      else {
          // mount时 后续的hook
          workInProgressHook.next = hook;
          workInProgressHook = hook;
      }
      return workInProgressHook;
  }

  /*
  * -作用：
      为传入的wip生成子fiberNode
  * -解释：
  *   对于 <A> <B/> </A> 的ReactElement结构
  *   当进入A的beginWork时，通过对比B的current fiberNode和B的 reactElement，
  *   生成B对应的新的wip fiberNode
  */
  const beginWork = (wip) => {
      // 比较，返回子fiberNode
      switch (wip.tag) {
          case HostRoot:
              // 1. 计算状态最新值
              // 2. 创造子fiberNode
              return updateHostRoot(wip);
          case HostComponent:
              // 1. 创造子fiberNode
              return updateHostComponent(wip);
          case HostText:
              // HostText没有子节点
              return null;
          case FunctionComponent:
              // HostText没有子节点
              return updateFunctionComponent(wip);
          default:
              {
                  console.warn('beginWork未实现的类型');
              }
              return null;
      }
  };
  function updateHostRoot(wip) {
      // 任务：
      // 1. 计算状态最新值
      // 2. 创造子fiberNode
      const baseState = wip.memorizedState;
      let updateQueue = wip.updateQueue;
      const pending = updateQueue?.shared?.pending;
      updateQueue.shared.pending = null;
      const { memorizedState } = processUpdateQueue(baseState, pending);
      wip.memorizedState = memorizedState;
      // 对于hostRoot，memorizedState其实就是子ReactElement
      const nextChildren = wip.memorizedState;
      reconcileChildren(wip, nextChildren);
      return wip.child;
  }
  function updateHostComponent(wip) {
      // 任务：
      // 1. 创造子fiberNode
      const nextProps = wip.pendingProps;
      // reactElement结构中，children在props里，那么nextChildren就在pendingProps中
      const nextChildren = nextProps.children;
      reconcileChildren(wip, nextChildren);
      return wip.child;
  }
  function updateFunctionComponent(wip) {
      wip.pendingProps;
      const nextChildren = renderWithHooks(wip);
      reconcileChildren(wip, nextChildren);
      return wip.child;
  }
  function reconcileChildren(wip, children) {
      const current = wip.alternate;
      if (current !== null) {
          // update
          wip.child = reconcileChildrenFibers(wip, current.child, children);
      }
      else {
          // mount
          wip.child = mountChildrenFibers(wip, null, children);
      }
  }

  function createInstance(type, props) {
      const element = document.createElement(type);
      return element;
  }
  function createTextInstance(content) {
      return document.createTextNode(content);
  }
  function appendInitialChild(parent, child) {
      parent.appendChild(child);
  }
  const appendChildToContainer = appendInitialChild;

  let nextEffect = null;
  function commitMutationEffects(finishedWork) {
      nextEffect = finishedWork;
      while (nextEffect !== null) {
          const child = nextEffect.child;
          // 以下又是一个DFS过程
          // 向下遍历，直到找到第一个不存在subtreeFlags的节点
          if ((nextEffect.subtreeFlags & MutationMask) !== NoFlags && child !== null) {
              // MutationMask是该阶段要操作的flag类型，包含三类
              nextEffect = child;
          }
          else {
              // 找到之后再向上遍历(执行对应操作)，如果存在sibling的话，继续从sibling节点开始向下遍历，如此往复
              up: while (nextEffect !== null) {
                  commitMutationEffectsOnFiber(nextEffect);
                  const sibling = nextEffect.sibling;
                  if (sibling !== null) {
                      nextEffect = sibling;
                      break up;
                  }
                  nextEffect = nextEffect.return;
              }
          }
      }
  }
  function commitMutationEffectsOnFiber(finishedWork) {
      const flags = finishedWork.flags;
      // Placement 执行操作，然后移除Placement标记
      if ((flags & Placement) !== NoFlags) {
          commitPlacement(finishedWork);
          finishedWork.flags &= ~Placement;
      }
      // Update 执行操作，然后移除Update标记
      // ChildDeletion 执行操作，然后移除PChildDeletion标记
  }
  function commitPlacement(finishedWork) {
      {
          console.warn('Mutation阶段，执行Placement对应操作', finishedWork);
      }
      // 找到parent对应的DOM
      const hostParent = getHostParent(finishedWork);
      if (hostParent) {
          // 找到当前fiber对应的DOM，并插到hostParent中
          appendPlacementNodeIntoContainer(finishedWork, hostParent);
      }
  }
  function getHostParent(fiber) {
      let parent = fiber.return;
      while (parent) {
          const parentTag = parent.tag;
          if (parentTag === HostComponent) {
              return parent.stateNode;
          }
          if (parentTag === HostRoot) {
              return parent.stateNode.container;
          }
          parent = parent.return;
      }
      {
          console.warn('未找到hostParent');
      }
      return null;
  }
  function appendPlacementNodeIntoContainer(finishedWork, hostParent) {
      if (finishedWork.tag === HostComponent || finishedWork.tag === HostText) {
          appendChildToContainer(hostParent, finishedWork.stateNode);
          return;
      }
      const child = finishedWork.child;
      if (child !== null) {
          appendChildToContainer(hostParent, child.stateNode);
          let sibling = child.sibling;
          while (sibling !== null) {
              appendChildToContainer(hostParent, sibling.stateNode);
              sibling = sibling.sibling;
          }
      }
  }

  /*
  * -作用：
      1. 将flags向上冒泡
      2. 为fiber创建dom
  */
  const completeWork = (wip) => {
      const newProps = wip.pendingProps;
      const current = wip.alternate;
      switch (wip.tag) {
          case HostRoot:
              bubbleProperties(wip);
              return null;
          case FunctionComponent:
              bubbleProperties(wip);
              return null;
          case HostComponent:
              if (current !== null && wip.stateNode) ;
              else {
                  // mount
                  // 1. 构建dom
                  const instance = createInstance(wip.type);
                  // 2. 将dom插入到dom树中
                  appendAllChildren(instance, wip);
                  wip.stateNode = instance;
              }
              bubbleProperties(wip);
              return null;
          case HostText:
              if (current !== null && wip.stateNode) ;
              else {
                  // mount
                  // 1. 构建dom
                  const instance = createTextInstance(newProps.content);
                  wip.stateNode = instance;
              }
              bubbleProperties(wip);
              return null;
          default:
              {
                  console.warn('completeWork未实现的类型');
              }
              bubbleProperties(wip);
              return null;
      }
  };
  function appendAllChildren(parent, wip) {
      let node = wip.child;
      while (node !== null) {
          if (node.tag === HostComponent || node.tag === HostText) {
              appendInitialChild(parent, node?.stateNode);
          }
          else if (node.child !== null) {
              // react组件只是react的一种数据结构，最终表示的是原生dom
              node.child.return = node;
              node = node.child;
              continue;
          }
          if (node === wip) {
              return;
          }
          while (node.sibling === null) {
              if (node.return === null || node.return === wip) {
                  return;
              }
              node = node?.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
      }
  }
  function bubbleProperties(wip) {
      // 将后代flags存在当前节点的subtreeFlags上
      let subtreeFlags = NoFlags;
      let child = wip.child;
      while (child !== null) {
          // 按位或方式将子fiberNode的subtreeFlags附加在当前节点的subtreeFlags上
          subtreeFlags |= child.subtreeFlags;
          // 在包含子节点本身的flags
          // 此时fiberNode的subtreeFlags就包含了子节点的subtreeFlags和flags，也就是全部子节点的flags
          subtreeFlags |= child.flags;
          child.return = wip;
          child = child.sibling;
      }
      wip.subtreeFlags |= subtreeFlags;
  }

  let workInProgress = null;
  function prepareFreshStack(root) {
      workInProgress = createWorkInProgress(root.current, {});
  }
  function scheduleUpdateOnFiber(fiber) {
      // TODO 调度
      // 向上找到fiberRootNode
      const root = markUpdateFromFiberToRoot(fiber);
      renderRoot(root);
  }
  function markUpdateFromFiberToRoot(fiber) {
      // 向上找到fiberRootNode
      let node = fiber;
      let parent = node.return;
      while (parent !== null) {
          node = parent;
          parent = node.return;
      }
      if (node.tag === HostRoot) {
          return node.stateNode;
      }
      return null;
  }
  function renderRoot(root) {
      prepareFreshStack(root);
      do {
          try {
              // 阶段一：render阶段开始
              workLoop();
              break;
          }
          catch (error) {
              {
                  console.warn('workLoop发生错误', error);
              }
              workInProgress = null;
          }
      } while (true);
      const finishedWork = root.current.alternate;
      root.finishedWork = finishedWork;
      // 阶段二：commit阶段开始
      // 根据wip 这颗fiberNode树，执行树中每个节点的flags
      commitRoot(root);
  }
  function workLoop() {
      while (workInProgress !== null) {
          performUnitOfWork(workInProgress);
      }
  }
  function performUnitOfWork(fiber) {
      const next = beginWork(fiber);
      fiber.memorizedProps = fiber.pendingProps;
      if (next === null) {
          completeUnitOfWork(fiber);
      }
      else {
          workInProgress = next;
      }
  }
  function completeUnitOfWork(fiber) {
      let node = fiber;
      do {
          completeWork(node);
          const sibling = node.sibling;
          if (sibling !== null) {
              workInProgress = sibling;
              return;
          }
          node = node.return;
          workInProgress = node;
      } while (node !== null);
  }
  function commitRoot(root) {
      // 任务：
      // 1. fiber树的切换
      // 2. 执行Placement对应操作
      const finishedWork = root.finishedWork;
      if (finishedWork === null) {
          return;
      }
      {
          console.warn('commit阶段开始', finishedWork);
      }
      root.finishedWork = null; // 重置
      // 判断是否存在3个字阶段需要执行的操作
      // root.flags  root.subtreeFlags
      const subtreeHasEffect = (finishedWork.subtreeFlags & MutationMask) !== NoFlags;
      const rootHasEffect = (finishedWork.flags & MutationMask) !== NoFlags;
      if (subtreeHasEffect || rootHasEffect) {
          // beforeMutation
          // mutation
          commitMutationEffects(finishedWork);
          root.current = finishedWork;
          // layout
      }
      else {
          root.current = finishedWork;
      }
  }

  function createContainer(container) {
      const hostRootFiber = new FiberNode(HostRoot, {}, null);
      const root = new FiberRootNode(container, hostRootFiber);
      hostRootFiber.updateQueue = createUpdateQueue();
      return root;
  }
  function updateContainer(element, root) {
      const hostRootFiber = root.current;
      const update = createUpdate(element);
      enqueueUpdate(hostRootFiber.updateQueue, update);
      scheduleUpdateOnFiber(hostRootFiber);
      return element;
  }

  function createRoot(container) {
      const root = createContainer(container);
      return {
          render(element) {
              return updateContainer(element, root);
          },
      };
  }

  var ReactDOM = /*#__PURE__*/Object.freeze({
    __proto__: null,
    createRoot: createRoot
  });

  return ReactDOM;

}));
